## 第一次小作业实验报告 

#### 2017011408 马天翼

#### 一.实验内容
1. 在模拟器中运行 MIPS32 监控程序，掌握 Term 中几个命令的使用方法。

2. 编写汇编程序，求前 10 个 Fibonacci 数，将结果保存到起始地址为 0x80400000 的 10 个字中，并用 D 命令检查结果正确性。

3. 编写汇编程序，将 ASCII 可见字符（0x21~0x7F）从终端输出。

4. 编写汇编程序，求第 60 个 Fibonacci 数，将结果保存到起始地址为 0x80400000 的 8 个字节中，并用 D 命令检查结果正确性。提示：计算过程中可以用两个 32 位寄存器保存 64 位整数。

5. 撰写实验报告，记录实验过程及汇编代码
#### 二.实验过程
##### 1.求解前十个Dibonacci数并存储到相应的内存单元

######  解题思路：

 利用两个寄存器存储数列值，一个寄存器当作中间过渡，利用sw指令将数值存储到内存。	

###### 实验代码：

li $2,40		\\\计数器上限数值
  	 li $3,0		\\\计数器
   	lui $4,0x8040		\\\存储地址初值
   	li $6,1		\\\第一个fib数
  	 li $7,1		\\\第二个fib数
   	sw $6,0($4)		\\\将第一个fib数存入内存
  	 addiu $3,$3,4		\\\将计数器增加4
  	 addiu $4,$4,4		\\\将地址增加4
  	 sw $7,0($4)	\\\将二个fib数存入内存
   	*addiu $5,$6,0	\\\将前一个fib数暂存（1）
  	 addiu $6,$7,0		\\\将最新的fib数存储做前一个fib数
   	addu $7,$7,$5		\\\计算得出下一个fib数
  	 addiu $3,$3,4		\\\计数器加4
   	addiu $4,$4,4		\\\地址加4
   	sw $7,0($4)		\\\存储当前的fib数
  	 bne $2,$3,-28		\\\若计数器没有到达40，则返回（1）行
  	 nop
  	 jr $31
  	 nop

###### 实验结果：

![1568719565(1)](C:\Users\11974\Desktop\1568719565(1).png)

可以看到相应内存地址已经被存储了正确的数值。

##### 2.打印ASCII字符

###### 求解思路：

利用SYSCALL命令即可。编译环境的时候将EN_INT=y加入。

###### 实验代码：

li $a1,0x80		\\\设置ascii码上限数值
		li $a0,0x21		\\\a0中存储需要被打印的字符
		li $v0,30		\\\存储打印字符的指令代号
		syscall		\\\调用syscall指令
		addiu $a0,$a0,1		\\\将字符数值加1
		bne $a1,$a0,-12		\\\如果没有到达上限，返回syscall调用哪一行
		nop
		jr $31
		nop

###### 实验结果：

![1568720063(1)](C:\Users\11974\Desktop\1568720063(1).png)

可以看到，所要的字符都被打印出来了。

##### 3.求解第60个fib

###### 求解思路：

方法与第一题类似，只不过要用两个32位寄存器存储每个fib数值。同时要考虑进位的问题。

###### 实验代码:

li $2,2		\\\记录当前计算到第几个fib数
		li $9,60		\\\计算到第六十个数的时候终止计算
		li $3,1		\\\前一个数的低32位
		li $4,0		\\\前一个数的高32位
		li $5,1		\\\当前数的低32位
		li $6,0		 \\\当前数的高32位
		li $7,0		\\\临时存储的低32位
		li $8,0		\\临时存储的高32位
		li $10,0x0000ffff		\\\辅助数值，便于获取一个数的低16位
		li $20,16		\\\常用右移位数
		addiu $2,$2,1		\\\计数器增加1
		addiu $7,$3,0		\\\将前一个数转移到临时存储寄存器，当前数转移到前一个数寄存器
		addiu $8,$4,0		\\\以便于计算新的一个数
		addiu $3,$5,0
		addiu $4,$6,0
		and $11,$3,$10		\\\获取前一个数的低16位
		and $12,$7,$10		\\\获取当前数的低16位
		addu $11,$12,$11		\\\ 将二者相加
		srl $11,$11,$20			\\\将结果右移16位，作为低16位相加的进位结果
		srl $13,$3,$20		\\\获取前一个数和当前数的16-31位
		srl $14,$7,$20
		addu $13,$14,$13		\\\相加
		addu $13,$11,$13		\\\加入进位
		srl $14,$13,$20		\\\右移16位，如果后32位相加有进位则为1，否则位0，作为进位
		addu $5,$7,$3		\\\低32位相加
		addu $6,$8,$4		\\\高32位相加
		addu $6,$6,$14		\\\加入进位
		bne $2,$9,-72
		nop
		lui $15,0x8040		\\\将数值存储进入相应的内存地址
		sw $5,0($15)
		sw $6,4($15)
		jr $31
		nop

###### 实验结果:

![1568721766(1)](C:\Users\11974\Desktop\1568721766(1).png)

经检验，这个结果确实是第60个gib数。

#### 三.实验总结

通过本次实验，我进一步熟悉了MIPS指令集的用法，也掌握了TERM工具的基本指令的使用方法。实验过程中，我也阅读了部分Kernel的代码，对模拟器的基本结构有了一定的了解。相信在后续的课程中，这些知识可以派上用场。

实验代码的git网址：

https://github.com/ITSTODAYY/Computer-Organization